# Перестановки

Проблема: необходимо найти все возможные перестановки в данной последовательности.

## Варианты решения

### Алгоритм Хипа

Алгоритм Хипа НЕ ЯВЛЯЕТСЯ эффективным, т.к. имеет сложность` O(n!)`.

Идея заключается в том, что все возможные комбинации элементов последовательности можно получить, специальным образом меняя эти элементы местами.

Алгоритм следующий:

Для первого вызова функции используем последовательность, для элементов которой хотим получить перестановки, и значение `k` равное длине последовательности.
1. Базовый случай. Проверить значение `k`. Если `k == 1` вернуть последовательность как текущую перестановку. Закончить вызов функции.
2. Используя цикл от индекса первого элемента до `k` с шагом 1 выполнять:
   1. Рекурсивно вызывать функцию, передавая последовательность и значение `k - 1`
   2. Если k чётное, то меняем местами `k` и `i` элементы, если нечётный — `k` и `0` элементы.

**Важно**: при реализации нужно учесть, что в оригинальном алгоритме индексация последовательности начинается с 1, и при замене элементов (шаг `2.ii`) необходимо менять местами элемент с индексом `k - 1`.

Ниже приводится полный разбор работы алгоритма для массива `['a', 'b', 'c']` (начиная с вызова функции `generate()`):

```
  1.1 [a,b,c], k = 3, i = 0

        |  2.1 [a,b,c], k = 2, i = 0
        |
        |     | 3. [a,b,c], k = 1
        |     | result = ['abc']
        |
        |     k%2 = 0: swap(i: 0, k: 2-1): arr = [a,b,c] => [b,a,c]
        |
        |  2.2 [b,a,c], k = 2, i = 1
        |
        |     | 3. [b,a,c], k = 1
        |     | result = ['abc', 'bac']
        |
        |     k%2 = 0: swap(i: 1, k: 2-1): arr = [b,a,c] => [b,a,c] (No changes)
        |

        k%2 = 1: swap (0; k: 3-1): arr = [b,a,c] => [c,a,b]

  1.2 [c,a,b], k = 3, i = 1

        |  2.1 [c,a,b], k = 2, i = 0
        |
        |     | 3. [c,a,b], k = 1
        |     | result = ['abc', 'bac', 'cab']
        |
        |     k%2 = 0: swap(i: 0, k: 2-1): arr = [c,a,b] => [a,c,b]
        |
        |  2.2 [a,c,b], k = 2, i = 1
        |
        |     | 3. [a,c,b], k = 1
        |     | result = ['abc', 'bac', 'cab', 'acb']
        |
        |     k%2 = 0: swap(i: 1, k: 2-1): arr = [a,c,b] => [a,c,b] (No changes)
        |

        k%2 = 1: swap (0; k: 3-1): arr = [a,c,b] => [b,c,a]

  1.3 [b,c,a], k = 3, i = 2

        |  2.1 [b,c,a], k = 2, i = 0
        |
        |     | 3. [b,c,a], k = 1
        |     | result = ['abc', 'bac', 'cab', 'acb', 'bca']
        |
        |     k%2 = 0: swap(i: 0, k: 2-1): arr = [b,c,a] => [c,b,a]
        |
        |  2.2 [c,b,a], k = 2, i = 1
        |
        |     | 3. [c,b,a], k = 1
        |     | result = ['abc', 'bac', 'cab', 'acb', 'bca', 'cba']
        |
        |     k%2 = 0: swap(i: 1, k: 2-1): arr = [c,b,a] => [c,b,a] (No changes)

        exit
```
